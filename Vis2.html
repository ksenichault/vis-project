<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>French baby-name popularity map (D3)</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 0;
        padding: 1rem;
        background: #fafafa;
      }
      #controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        margin-bottom: 1rem;
        flex-wrap: wrap;
      }
      label {
        font-weight: 600;
      }
      input[type="text"] {
        padding: 0.3rem 0.5rem;
        border: 1px solid #ccc;
        border-radius: 4px;
        min-width: 110px;
      }
      input[type="number"] {
        width: 5rem;
      }
      svg {
        background: white;
        border: 1px solid #ddd;
        border-radius: 6px;
      }
      .dept {
        stroke: white;
        stroke-width: 0.7;
      }
      .tooltip {
        pointer-events: none;
        position: absolute;
        opacity: 0;
        background: #333;
        color: #fff;
        padding: 0.4rem 0.6rem;
        border-radius: 4px;
        font-size: 0.85rem;
        white-space: nowrap;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <label>
        Name :
        <input
          id="nameInput"
          type="text"
          value="ANNA"
          placeholder="first name"
        />
        <datalist id="nameList"></datalist>
      </label>

      <label>
        Year from
        <input id="yearFrom" type="number" value="1900" min="1900" max="2020" />
      </label>
      <label>
        to
        <input id="yearTo" type="number" value="2020" min="1900" max="2020" />
      </label>
    </div>

    <svg id="map" width="800" height="600"></svg>
    <div class="tooltip" id="tooltip"></div>

    <script src="libs/d3.v7.min.js"></script>
    <!-- topojson is optional; we’re using GeoJSON directly -->
    <script>
      // ---------- Config ----------
      const csvFile = "./data/dpt2020.csv";
      const geoFile = "./data/departements-version-simplifiee.geojson"; // simplified GeoJSON
      const width = 800,
        height = 600;
      const svg = d3.select("#map").attr("viewBox", [0, 0, width, height]);

      const tooltip = d3.select("#tooltip");

      const projection = d3
        .geoConicConformal() // Lambert 93-ish
        .center([2.454071, 46.279229]) // France centre
        .scale(2600) // tweak so it fits
        .translate([width / 2, height / 2]);

      const path = d3.geoPath(projection);

      // ---------- Load data ----------
      Promise.all([
        d3.json(geoFile),
        d3.dsv(";", csvFile, (row) => ({
          // correct function param
          // skip the “_PRENOMS_RARES” and bogus 'XX' rows if you like
          dpt: row.dpt,
          name: row.preusuel.toUpperCase(),
          year: +row.annais,
          count: +row.nombre,
        })),
      ]).then(initialize);

      function initialize([france, birthsRaw]) {
        /* ───────────────── 1.  projection + base map */
        projection.fitSize([width, height], france);

        const depts = svg
          .append("g")
          .selectAll("path")
          .data(france.features)
          .enter()
          .append("path")
          .attr("d", path)
          .attr("class", "dept")
          .attr("fill", "#eee");

        /* ───────────────── 2.  shared state */
        const selected = new Set(); // TAGGED names (UPPER-CASE)
        let totals = new Map(); // dpt → combined count
        let latestType = ""; // current text in the box

        /* ───────────────── 3.  tooltip */
        const tooltipHtml = (p) => {
          const lines = [];
          selected.forEach((n) => {
            const v = nameTotals.get(n)?.get(p.code) ?? 0;
            lines.push(
              `${n[0]}${n.slice(1).toLowerCase()}: <strong>${v}</strong>`
            );
          });
          const sum = totals.get(p.code) || 0;
          return `<strong>${p.nom} (${p.code})</strong><br>${lines.join("<br>")}
            ${selected.size > 1 ? `<hr>Total: <strong>${sum}</strong>` : ""}`;
        };

        depts
          .on("mousemove", (e, d) => {
            const [mx, my] = d3.pointer(e);
            tooltip
              .style("opacity", 1)
              .style("left", mx + 15 + "px")
              .style("top", my + 15 + "px")
              .html(tooltipHtml(d.properties));
          })
          .on("mouseout", () => tooltip.style("opacity", 0));

        /* ───────────────── 4.  data roll-ups */
        const births = d3.rollup(
          birthsRaw,
          (v) =>
            d3.rollup(
              v,
              (vv) =>
                d3.rollup(
                  vv,
                  (vvv) => d3.sum(vvv, (r) => r.count),
                  (r) => r.year
                ),
              (r) => r.name
            ),
          (r) => r.dpt
        );

        const nameTotals = new Map(); // name → Map(dpt → all-years sum)
        births.forEach((nameMap, dpt) => {
          nameMap.forEach((yearMap, n) => {
            let m = nameTotals.get(n);
            if (!m) {
              m = new Map();
              nameTotals.set(n, m);
            }
            m.set(dpt, d3.sum(yearMap.values()));
          });
        });

        /* ───────────────── 5.  controls */
        const allNames = Array.from(nameTotals.keys()).sort();
        const nameInput = d3.select("#nameInput");
        const datalist = d3.select("#nameList");
        const yearFrom = d3.select("#yearFrom");
        const yearTo = d3.select("#yearTo");
        if (!nameInput.attr("list")) nameInput.attr("list", "nameList");

        const tagBar = d3
          .select("#controls")
          .append("div")
          .attr("id", "tagBar")
          .style("display", "flex")
          .style("gap", ".4rem")
          .style("align-items", "center");

        nameInput.on("input", () => {
          latestType = nameInput.property("value").trim().toUpperCase();

          const q = latestType;
          const sugg = q
            ? allNames.filter((n) => n.startsWith(q)).slice(0, 10)
            : allNames.slice(0, 10);

          datalist.selectAll("option").remove();
          datalist
            .selectAll("option")
            .data(sugg)
            .enter()
            .append("option")
            .attr("value", (d) => d[0] + d.slice(1).toLowerCase());

          /* ★ always keep the list attribute—some browsers drop it */
          nameInput.attr("list", "nameList"); /* ★ */

          update(); // still live-preview if no tag yet
        });

        nameInput.on("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            tryAddTag();
          }
        });
        nameInput.on("change", tryAddTag);

        function tryAddTag() {
          const cand = nameInput.property("value").trim().toUpperCase();
          if (cand && nameTotals.has(cand) && !selected.has(cand)) {
            selected.add(cand);
            renderTags();
            nameInput.property("value", "");
            latestType = "";
            update();
          }
        }

        yearFrom.on("input change", clampYears);
        yearTo.on("input change", clampYears);

        function clampYears() {
          let f = +yearFrom.property("value");
          let t = +yearTo.property("value");
          f = Math.max(1900, Math.min(2020, f));
          t = Math.max(1900, Math.min(2020, t));
          if (t < f) [f, t] = [t, f];
          yearFrom.property("value", f);
          yearTo.property("value", t);
          update();
        }

        /* ───────────────── 6.  tag renderer */
        function renderTags() {
          const tags = tagBar
            .selectAll("span.tag")
            .data(Array.from(selected), (d) => d);

          tags.exit().remove();

          const enter = tags
            .enter()
            .append("span")
            .attr("class", "tag")
            .style("background", "#e0e0e0")
            .style("padding", ".5rem .8rem")
            .style("border-radius", "9999px")
            .style("cursor", "pointer")
            .style("user-select", "none")
            .style("font-size", ".8rem")
            .text((d) => d[0] + d.slice(1).toLowerCase() + " ×")
            .on("click", (e, d) => {
              selected.delete(d);
              renderTags();
              update();
            });

          tags.merge(enter);
        }

        /* ───────────────── 7.  legend scaffolding */
        const legendWidth = 18,
          legendHeight = 200,
          legendX = width - legendWidth - 40,
          legendY = 20;

        const defs = svg.append("defs");
        const grad = defs
          .append("linearGradient")
          .attr("id", "legendGrad")
          .attr("x1", 0)
          .attr("y1", 1)
          .attr("x2", 0)
          .attr("y2", 0);

        grad
          .selectAll("stop")
          .data(d3.range(0, 1.001, 0.1))
          .enter()
          .append("stop")
          .attr("offset", (d) => d)
          .attr("stop-color", "#eee");

        const legendG = svg
          .append("g")
          .attr("transform", `translate(${legendX},${legendY})`);

        legendG
          .append("rect")
          .attr("width", legendWidth)
          .attr("height", legendHeight)
          .attr("fill", "url(#legendGrad)")
          .attr("stroke", "#666")
          .attr("stroke-width", 0.5);

        const legendScale = d3.scaleLinear().range([legendHeight, 0]);
        const legendAxis = legendG
          .append("g")
          .attr("class", "legendAxis")
          .attr("transform", `translate(${legendWidth},0)`);

        /* ───────────────── 8.  map + legend repaint */
        function update() {
          const namesToPlot = selected.size
            ? Array.from(selected)
            : latestType
            ? [latestType]
            : [];

          const f = +yearFrom.property("value");
          const t = +yearTo.property("value");

          totals = new Map();
          namesToPlot.forEach((n) => {
            births.forEach((nameMap, dpt) => {
              const yrs = nameMap.get(n);
              if (!yrs) return;
              let s = 0;
              for (let y = f; y <= t; y++) s += yrs.get(y) || 0;
              if (s) totals.set(dpt, (totals.get(dpt) || 0) + s);
            });
          });

          const max = d3.max(totals.values()) || 1;
          const colour = d3
            .scaleSequential()
            .domain([0, max])
            .interpolator(d3.interpolateBlues);

          depts
            .attr("fill", (d) => colour(totals.get(d.properties.code) || 0))
            .attr("data-count", (d) => totals.get(d.properties.code) || 0);

          grad.selectAll("stop").attr("stop-color", (d) => colour(d * max));

          legendScale.domain([0, max]);
          legendAxis.call(
            d3
              .axisRight(legendScale)
              .ticks(6)
              .tickFormat(d3.format(","))
              .tickSize(3)
          );
        }

        /* first paint */
        clampYears(); // also calls update()
      }
    </script>
  </body>
</html>
